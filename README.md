# Звіт

**1. Загальна інформація про мікросхему**

**74LS374** — це 8-розрядний D-тригер із синхронізацією по позитивному фронту тактового сигналу (positive-edge-triggered flip-flop). OCTAL D-TYPE FLIP FLOPWITH 3 STATE OUTPUT NON INVERTING

**Основні характеристики:**

Тип: Octal D-Type Edge-Triggered Flip-Flop

Кількість тригерів: 8 незалежних D-тригерів

Синхронізація: По позитивному фронту (rising edge) сигналу CLK

Виходи: 3-state (три стани) з можливістю вимкнення через сигнал OE (Output Enable)

Живлення: VCC (5V), GND

**Розпіновка (20-pin DIP):**

D0-D7: входи даних (8 біт) (піни 3, 4, 7, 8, 13, 14, 17, 18 відповідно)

Q0-Q7: виходи даних (8 біт) (піни 2, 5, 6, 9, 12, 15, 16, 19 відповідно)

CP (CK): тактовий вхід (активний по фронту 0→1) (пін 11)

OE: дозвіл виходів (активний 0) (пін 1)

VCC: Живлення (+3.5V) (пін 20)

GND: Земля (пін 10)

2. Принцип роботи мікросхеми 74374
2.1 Функціональна таблиця:

Де:

L — низький рівень (0)
H — високий рівень (1)
↑ — позитивний фронт (перехід з 0 в 1)
X — будь-який стан
Q₀ — попередній стан
Z — високий імпеданс (вихід відключений)

**2.2 Як працює:**

Захоплення даних: Дані на входах D0-D7 захоплюються тільки в момент позитивного фронту сигналу CLK (коли CLK переходить з 0 в 1)

Зберігання даних: Після захоплення дані зберігаються на виходах Q0-Q7 незалежно від змін на входах D0-D7, поки не відбудеться наступний позитивний фронт CLK

Керування виходами: Сигнал OE (Output Enable) керує станом виходів:

OE = 0 (LOW) → виходи активні, показують збережені дані

OE = 1 (HIGH) → виходи у стані високого імпедансу (відключені)

3. Схема підключення до мікроконтролера
3.1 Піни мікроконтролера (PSoC):
Виходи мікроконтролера → Входи мікросхеми:

D0 → 1D (пін 3) — біт 0 даних
D1 → 2D (пін 4) — біт 1 даних
D2 → 3D (пін 7) — біт 2 даних
D3 → 4D (пін 8) — біт 3 даних
D4 → 5D (пін 13) — біт 4 даних
D5 → 6D (пін 14) — біт 5 даних
D6 → 7D (пін 17) — біт 6 даних
D7 → 8D (пін 18) — біт 7 даних
CK → CLK (пін 11) — тактовий сигнал
OE → OE (пін 1) — дозвіл виходів

Входи мікроконтролера ← Виходи мікросхеми:

Q0 ← 1Q (пін 2) — біт 0 виходу
Q1 ← 2Q (пін 5) — біт 1 виходу
Q2 ← 3Q (пін 6) — біт 2 виходу
Q3 ← 4Q (пін 9) — біт 3 виходу
Q4 ← 5Q (пін 12) — біт 4 виходу
Q5 ← 6Q (пін 15) — біт 5 виходу
Q6 ← 7Q (пін 16) — біт 6 виходу
Q7 ← 8Q (пін 19) — біт 7 виходу

Індикація:

LED_OK — світлодіод "Справна"
LED_FAIL — світлодіод "Несправна"

4. Детальний аналіз коду програми
4.1 Константи та макроcи
```b
#define T_US 10
```
Призначення: Базова затримка 10 мкс для забезпечення коректної роботи мікросхеми. Це значно більше за мінімальні часові параметри (tsu=20нс, th=5нс), що гарантує надійність.
```b
#define SET_D(v) do { \
    D0_Write((v >> 0) & 1); \
    D1_Write((v >> 1) & 1); \
    D2_Write((v >> 2) & 1); \
    D3_Write((v >> 3) & 1); \
    D4_Write((v >> 4) & 1); \
    D5_Write((v >> 5) & 1); \
    D6_Write((v >> 6) & 1); \
    D7_Write((v >> 7) & 1); \
} while (0)
```
Призначення: Встановлює 8-бітне значення на входи D0-D7.

(v >> n) & 1 — витягує n-й біт числа v
Наприклад, для v=0b10110101 (181):

D0 = 1, D1 = 0, D2 = 1, D3 = 0, D4 = 1, D5 = 1, D6 = 0, D7 = 1
```b
#define READ_Q() ( \
    (Q0_Read() << 0) | \
    (Q1_Read() << 1) | \
    (Q2_Read() << 2) | \
    (Q3_Read() << 3) | \
    (Q4_Read() << 4) | \
    (Q5_Read() << 5) | \
    (Q6_Read() << 6) | \
    (Q7_Read() << 7) )
```
Призначення: Читає стан виходів Q0-Q7 і формує 8-бітне число.

Кожен біт зсувається на відповідну позицію і об'єднується через OR

4.2 Функція генерації позитивного фронту
```b
void clock_rising_edge(void)
{
    CK_Write(0);              // 1. CLK = 0
    CyDelayUs(T_US);          // 2. Затримка 10 мкс
    CK_Write(1);              // 3. CLK = 1 (позитивний фронт!)
    CyDelayUs(T_US);          // 4. Затримка 10 мкс
    CK_Write(0);              // 5. CLK = 0
    CyDelayUs(T_US);          // 6. Затримка 10 мкс
}
```

**Часова діаграма:**
```
CLK: _____|‾‾‾‾‾|_____
         ↑
    Момент захоплення даних
    
t=0мкс   t=10мкс  t=20мкс  t=30мкс
```
Що відбувається:

CLK встановлюється в 0 (якщо був 1)
Чекаємо 10 мкс (дані на D0-D7 стабілізуються)
CLK переходить з 0 в 1 — це і є позитивний фронт, у цей момент дані з D0-D7 записуються у тригери
CLK залишається в 1 протягом 10 мкс
CLK повертається в 0
Готові до наступного циклу

**4.3 Функція тестування**
```
bool test_74374(void)
{
    // ТЕСТ 1: Перевірка всіх можливих значень (0-255)
    for (uint16_t v = 0; v < 256; v++)
    {
        SET_D(v);                    // Встановлюємо дані
        CyDelayUs(T_US);             // Чекаємо стабілізації (setup time)
        clock_rising_edge();          // Генеруємо фронт CLK
        
        if (READ_Q() != v)           // Перевіряємо, чи дані записалися
            return false;
        
        // ТЕСТ 2: Перевірка збереження даних
        for (uint8_t i = 0; i < 20; i++)
        {
            SET_D((i * 73) & 0xFF);  // Змінюємо входи на випадкові значення
            CyDelayUs(T_US);
            if (READ_Q() != v)       // Виходи НЕ повинні змінюватися!
                return false;
        }
    }
    
    // ТЕСТ 3: Перевірка окремих бітів
    for (uint8_t b = 0; b < 8; b++)
    {
        uint8_t m = 1 << b;          // Маска: 0b00000001, 0b00000010, 0b00000100...
        SET_D(m);
        CyDelayUs(T_US);
        clock_rising_edge();
        if (READ_Q() != m)
            return false;
    }
    
    return true;                     // Всі тести пройдено!
}
```

### 4.4 Детальний розбір тестів

#### **ТЕСТ 1: Повний перебір (0-255)**

**Мета**: Перевірити, що всі 256 можливих комбінацій даних коректно записуються і зберігаються.

**Приклад для v = 42 (0b00101010):**
```
Крок 1: SET_D(42)
   D7 D6 D5 D4 D3 D2 D1 D0
   0  0  1  0  1  0  1  0

Крок 2: CyDelayUs(10)
   Дані стабілізувалися на входах

Крок 3: clock_rising_edge()
   CLK: 0 → 1 → 0
          Захоплення даних

Крок 4: READ_Q()
   Q7 Q6 Q5 Q4 Q3 Q2 Q1 Q0
   0  0  1  0  1  0  1  0  = 42

Крок 5: Якщо READ_Q() != 42 → FAIL
```

#### **ТЕСТ 2: Перевірка збереження даних (незалежність від входів)**

**Мета**: Переконатися, що дані **зберігаються** у тригерах і **не змінюються**, коли змінюються входи D0-D7 (без фронту CLK).

**Приклад після запису v = 42:**
```
Ітерація i=0:
   SET_D((0 * 73) & 0xFF) = SET_D(0)
   D7-D0: 0000 0000  (входи змінилися!)
   
   CyDelayUs(10)
   
   READ_Q() повинно дати 42, а не 0!
   Q7-Q0: 0010 1010 = 42

Ітерація i=1:
   SET_D((1 * 73) & 0xFF) = SET_D(73)
   D7-D0: 0100 1001  (входи змінилися знову!)
   
   READ_Q() все ще повинно дати 42!
   Q7-Q0: 0010 1010 = 42

... і так 20 разів з різними значеннями
```

**Чому це важливо**: Це головна властивість D-тригера — дані захоплюються **тільки** по фронту CLK, а не весь час.

#### **ТЕСТ 3: Побітова перевірка**

**Мета**: Перевірити кожен біт окремо, щоб впевнитися, що немає "застряглих" бітів або короткого замикання між лініями.
```
b=0: m = 0b00000001 → Q повинно дати 0b00000001
b=1: m = 0b00000010 → Q повинно дати 0b00000010
b=2: m = 0b00000100 → Q повинно дати 0b00000100
b=3: m = 0b00001000 → Q повинно дати 0b00001000
b=4: m = 0b00010000 → Q повинно дати 0b00010000
b=5: m = 0b00100000 → Q повинно дати 0b00100000
b=6: m = 0b01000000 → Q повинно дати 0b01000000
b=7: m = 0b10000000 → Q повинно дати 0b10000000
```
**4.5 Головна функція**
```b
int main(void)
{
    CyGlobalIntEnable;           // Дозволити переривання (не використовуються)
    
    // Ініціалізація всіх сигналів
    OE_Write(0);                 // Дозволити виходи (OE активний LOW)
    CK_Write(0);                 // CLK в початковому стані 0
    SET_D(0);                    // Всі входи D в 0
    LED_OK_Write(0);             // Вимкнути світлодіоди
    LED_FAIL_Write(0);
    
    CyDelay(100);                // Затримка 100 мс для стабілізації живлення
    
    // Запуск тестування
    if (test_74374())            // Якщо всі тести пройдено
    {
        LED_OK_Write(1);         // Увімкнути зелений світлодіод
        LED_FAIL_Write(0);
    }
    else                         // Якщо хоча б один тест провалився
    {
        LED_OK_Write(0);
        LED_FAIL_Write(1);       // Увімкнути червоний світлодіод
    }
    
    // Нескінченний цикл (демонстрація роботи)
    for (;;)
    {
        CyDelay(1000);            // Чекати 1000 мс
    }
}
```
## 5. Які дефекти виявляє тестер

5.1 Несправності захоплення даних:

1. Тригер не захоплює дані по фронту CLK
2. Дані захоплюються не по фронту, а постійно (як захват)
3. Затримка захоплення надто велика

Як виявляє: ТЕСТ 1 — після clock_rising_edge() виходи повинні дорівнювати входам.
5.2 Несправності збереження:

1. Дані не зберігаються після фронту
2. Виходи "слідкують" за входами (поламаний синхронізатор)

5.3 Застряглі біти:

1. Біт завжди 0 або завжди 1
2. Короткі замикання між лініями

Як виявляє: ТЕСТ 3 — кожен біт перевіряється окремо.

5.4 Несправності CLK:

1. CLK не впливає на тригери
2. Неправильна полярність (захоплення по спаду замість фронту)

Як виявляє: ТЕСТ 2 — без фронту дані не повинні змінюватися.

5.5 Несправності OE:

1. Виходи завжди у Z-стані
2. OE не працює

* Затримка 10 мкс >> 20 нс (setup time) — гарантія стабільності
* Частота тестування ~30 кГц << 50 МГц (fmax) — надійність

## Висновок
* 256 комбінацій даних → кожен можливий байт протестовано
* 8 окремих бітів → кожна лінія перевірена ізольовано
* 20 випадкових змін після кожного запису → збереження протестовано
*  Перевіряє роботу всіх 8 тригерів
* Перевіряє синхронізацію по CLK (позитивний фронт)
* Перевіряє незалежність виходів від входів (без фронту)
* Світлодіодна індикація (справна/несправна)
